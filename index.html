<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>The Space Stuff</title>

    <!--
        MIT License

        Copyright (c) 2025 Maxim Bortnikov

        Permission is hereby granted, free of charge, to any person obtaining a copy
        of this software and associated documentation files (the "Software"), to deal
        in the Software without restriction, including without limitation the rights
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the Software is
        furnished to do so, subject to the following conditions:

        The above copyright notice and this permission notice shall be included in all
        copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        SOFTWARE.
    -->

    <!--
        Credit:
            https://codepen.io/Gopi-Chakradhar/pen/NPGBopb
            https://codepen.io/VoXelo/pen/dPMeGze
            https://unpkg.com/react@18/umd/react.production.min.js
            https://unpkg.com/react-dom@18/umd/react-dom.production.min.js
            https://unpkg.com/@babel/standalone/babel.min.js
            https://www.npmjs.com/package/radix-ui
            https://21st.dev/Edil-ozi/custom-checkbox/default
            https://codepen.io/ash_creator/pen/JjZReNm
            https://codepen.io/ash_creator/pen/zYaPZLB
            https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js
            https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/
            https://cdn.jsdelivr.net/npm/animejs@3.2.2/lib/anime.es.js
            https://cdn.skypack.dev/simplex-noise@4.0.1
    -->

    <!-- React & Babel -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Three.js Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/",
                "animejs": "https://cdn.jsdelivr.net/npm/animejs@3.2.2/lib/anime.es.js",
                "simplex-noise": "https://cdn.skypack.dev/simplex-noise@4.0.1"
            }
        }
    </script>

    <style>
        /* Losing Alice & Halo Aesthetic */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000810; /* Abyssal Navy */
            font-family: 'Segoe UI', 'Courier New', monospace;
            user-select: none;
            color: #88f;
        }

        #root {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            direction: ltr;
            z-index: 10;
        }

        canvas {
            display: block;
            outline: none;
            z-index: 1;
        }

        .panel {
            background: rgba(10, 10, 10, 0.6);
            backdrop-filter: blur(11px) saturate(180%);
            -webkit-backdrop-filter: blur(11px) saturate(180%);
            border: 1px solid rgba(255,255,255,0.08);
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 10px;
            max-width: 320px;
            font-weight: 600;
        }

        /* HUD UI with neon-glow and mystic colors */
        .hud-wrapper {
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 100vh;
            padding: 20px;
            box-sizing: border-box;
            color: #99aaff;
            text-shadow: 0 0 12px rgba(153,170,255,0.85);
        }

        .panel {
            background: rgba(5, 8, 20, 0.75);
            border: 1px solid #5a5eff;
            padding: 15px;
            border-radius: 6px;
            backdrop-filter: blur(8px);
            max-width: 320px;
            font-weight: 600;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            border-bottom: 1px solid #3344ff66;
            padding-bottom: 6px;
        }

        h2 {
            margin: 0;
            font-size: 20px;
            text-transform: uppercase;
            letter-spacing: 3px;
            color: #aabbee;
        }

        .control-group {
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
        }

        .control-panel {
            display: flex;
            flex-direction: column;
            gap: 16px;
            margin-bottom: 12px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            margin-bottom: 8px;
        }

        .control-group label {
            margin-bottom: 4px;
        }

        input[type="range"] {
            margin-bottom: 0;
        }
                
        input[type="text"] {
            background: #12131f;
            border: 1px solid #5a5eff;
            color: #ccddee;
            padding: 6px;
            width: 140px;
            font-family: monospace;
            border-radius: 4px;
        }

        button {
            background: rgba(0, 80, 180, 0.7);
            color: #eef5ff;
            border: 1px solid rgba(0, 180, 255, 0.6);
            padding: 7px 18px;
            font-weight: 700;
            cursor: pointer;
            text-transform: uppercase;
            border-radius: 5px;
            transition: all 0.3s ease;
        }
        button:hover {
            background: rgba(0, 110, 220, 0.9);
            box-shadow: 0 0 14px #99aaff;
        }

        .status-dot {
            width: 12px; height: 12px;
            border-radius: 50%;
            background: #222;
            display: inline-block;
            margin-right: 6px;
        }
        .status-dot.connected { background: #55ff88; box-shadow: 0 0 14px #55ff88; }
        .status-dot.error { background: #ff5555; box-shadow: 0 0 14px #ff5555; }

        .data-display {
            font-family: monospace;
            font-size: 13px;
            color: #99aacc;
            margin-top: 12px;
            line-height: 1.6;
        }
        .val { color: #ccddee; font-weight: 700; }

        /* Hebrew Text Special Styling */
        .hebrew-text {
            direction: rtl;
            unicode-bidi: embed;
            font-weight: 700;
            font-family: 'Arial Hebrew', 'Segoe UI', monospace;
            font-size: 16px;
        }

        #loading {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000810;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.8s ease-out;
            pointer-events: none;
        }
        #loading.fade-out { opacity: 0; }
        .loader-text { color: #5a5eff; letter-spacing: 4px; margin-bottom: 20px; font-family: monospace;}
    </style>
</head>
<body>
    <div id="loading"><div class="loader-text">Loading...</div></div>
    <div id="root"></div>

    <script type="text/babel">
        window.gameData = {
            inputs: { jx: 128, jy: 128, ax: 512, ay: 512, c: 0, z: 0 },
            settings: {
            accelEnabled: true,
            invertX: true,
            invertY: false,
            sensitivity: 1.5,
            deadzone: 0.2,
            accelEnableX: true,
            accelEnableY: true,
            },
            telemetry: { x: 0, y: 0, z: 0, speed: 0 },
            velocity: { x: 0, y: 0, z: 0 },
        };

        window.currentHue = window.currentHue ?? 0.6;

        const supportsBackdropFilter =
            typeof CSS !== "undefined" &&
            CSS.supports &&
            (CSS.supports("backdrop-filter: blur(1px)") ||
            CSS.supports("-webkit-backdrop-filter: blur(1px)"));

        // Neutral glassy background for cards (no hue tint)
        function getLegacyBackdropStyle({
            supportsBackdropFilter,
            bodyOpacity,
            borderOpacity,
            blurStrength,
            isScrolled = false,
        }) {
            const invisibleOpacity = 0;
            const baseBgOpacity = isScrolled ? bodyOpacity : invisibleOpacity;
            const borderAlpha = Math.min(baseBgOpacity + 0.08, 0.4); // Slightly lighter than background
            const bgColor = `rgba(10,10,20,${baseBgOpacity})`;

            return {
            background: supportsBackdropFilter
                ? bgColor
                : `rgba(10,10,20,${baseBgOpacity + 0.2})`,
            backdropFilter: supportsBackdropFilter
                ? `blur(${isScrolled ? blurStrength : 0}px) saturate(180%)`
                : undefined,
            WebkitBackdropFilter: supportsBackdropFilter
                ? `blur(${isScrolled ? blurStrength : 0}px) saturate(180%)`
                : undefined,
            border: `1px solid rgba(80,80,80,${borderAlpha})`,
            boxShadow: isScrolled ? "0 8px 32px rgba(0,0,0,0.5)" : "none",
            transition:
                "background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease, backdrop-filter 0.3s ease, -webkit-backdrop-filter 0.3s ease",
            borderRadius: "10px",
            };
        }

        function CustomCheckbox({
            checked = false,
            onChange,
            disabled = false,
            label,
            size = 20,
            accentColor = "rgba(140,190,255,0.9)",
            borderRadius = "6px",
            borderWidth = 1.4,
            labelColor = "rgba(255,255,255,0.8)",
            glowColor = "rgba(140,190,255,0.4)",
        }) {
            const [hovered, setHovered] = React.useState(false);

            const handleToggle = () => {
            if (disabled) return;
            if (onChange) onChange(!checked);
            };

            const baseBg = "rgba(8, 12, 20, 0.7)";
            const baseBorder = "rgba(180, 210, 255, 0.65)";
            const boxShadow = hovered || checked ? `0 0 6px 2px ${glowColor}` : "none";
            const fillBg = checked ? accentColor : baseBg;
            const borderColor = checked ? accentColor : baseBorder;

            return (
            <label
                style={{
                display: "inline-flex",
                alignItems: "center",
                cursor: disabled ? "not-allowed" : "pointer",
                userSelect: "none",
                gap: 8,
                opacity: disabled ? 0.5 : 1,
                }}
                onMouseEnter={() => setHovered(true)}
                onMouseLeave={() => setHovered(false)}
                onClick={handleToggle}
                tabIndex={disabled ? -1 : 0}
                onKeyDown={(e) => {
                if ((e.key === " " || e.key === "Enter") && !disabled) {
                    e.preventDefault();
                    handleToggle();
                }
                }}
                role="checkbox"
                aria-checked={checked}
                aria-disabled={disabled}
            >
                <div
                style={{
                    width: size,
                    height: size,
                    borderRadius,
                    background: fillBg,
                    border: `${borderWidth}px solid ${borderColor}`,
                    boxShadow,
                    transition: "background 0.25s ease, border-color 0.25s ease, box-shadow 0.3s ease",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    position: "relative",
                    flexShrink: 0,
                }}
                >
                {checked && (
                    <svg
                    width={size * 0.6}
                    height={size * 0.6}
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="#ffffff"
                    strokeWidth="3"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    style={{ pointerEvents: "none", userSelect: "none" }}
                    >
                    <polyline points="20 6 9 17 4 12" />
                    </svg>
                )}
                </div>
                {label && (
                <span
                    style={{
                    color: labelColor,
                    fontSize: 14,
                    userSelect: "text",
                    }}
                >
                    {label}
                </span>
                )}
            </label>
            );
        }

        function CustomSlider({
            id,
            min = 0,
            max = 100,
            step = 1,
            value,
            onValueChange,
            disabled = false,
            trackHeight = "6px",
            thumbWidth = "16px",
            thumbHeight = "16px",
            width = "220px",
            trackFillBorderRadius = "999px",
            thumbBorderRadius = "999px",
            thumbBorderWidth = "1.3px",
            colorTrackBackground = "rgba(10,10,10,0.2)",
            colorFillDefault = "rgba(140,190,255,0.75)",
            colorFillHover = "rgba(180,215,255,0.9)",
            colorFillActive = "rgba(210,235,255,0.95)",
            colorThumbDefault = "rgba(10,12,24,0.9)",
            colorThumbHover = "rgba(26,32,54,0.95)",
            colorThumbActive = "rgba(230,240,255,1.0)",
            colorThumbBorderDefault = "rgba(160,210,255,0.85)",
            colorThumbBorderHover = "rgba(200,230,255,0.95)",
            colorThumbBorderActive = "rgba(255,255,255,1.0)",
            ariaLabel = "slider",
            isRTL = false,
            keyStep = 1,
        }) {
            const sliderRef = React.useRef(null);
            const [isDragging, setIsDragging] = React.useState(false);
            const [isFocused, setIsFocused] = React.useState(false);
            const [isHovered, setIsHovered] = React.useState(false);

            const getPercentage = React.useCallback(() => {
            return ((value - min) / (max - min)) * 100;
            }, [value, min, max]);

            const handleInteraction = React.useCallback(
            (clientX) => {
                if (disabled || !sliderRef.current) return;
                const rect = sliderRef.current.getBoundingClientRect();
                let percentage = isRTL
                ? ((rect.right - clientX) / rect.width) * 100
                : ((clientX - rect.left) / rect.width) * 100;
                percentage = Math.max(0, Math.min(100, percentage));
                let newValue = min + (percentage / 100) * (max - min);
                if (step !== 0) newValue = Math.round(newValue / step) * step;
                newValue = Math.max(min, Math.min(max, newValue));
                onValueChange(newValue);
            },
            [disabled, min, max, step, onValueChange, isRTL]
            );

            const handleMouseDown = (e) => {
            if (disabled) return;
            setIsDragging(true);
            handleInteraction(e.clientX);
            sliderRef.current && sliderRef.current.focus();
            };

            const handleMouseMove = React.useCallback(
            (e) => {
                if (isDragging) handleInteraction(e.clientX);
            },
            [isDragging, handleInteraction]
            );

            const handleMouseUp = React.useCallback(() => {
            setIsDragging(false);
            }, []);

            const handleKeyDown = (e) => {
            if (disabled) return;
            if (e.key === "ArrowLeft" || e.key === "ArrowRight") {
                e.preventDefault();
                const direction = (e.key === "ArrowRight" ? 1 : -1) * (isRTL ? -1 : 1);
                const increment = keyStep ?? step;
                const newValue = Math.max(
                min,
                Math.min(max, value + direction * increment)
                );
                onValueChange(newValue);
            }
            };

            React.useEffect(() => {
            window.addEventListener("mousemove", handleMouseMove);
            window.addEventListener("mouseup", handleMouseUp);
            return () => {
                window.removeEventListener("mousemove", handleMouseMove);
                window.removeEventListener("mouseup", handleMouseUp);
            };
            }, [handleMouseMove, handleMouseUp]);

            const percentage = getPercentage();
            const fillColor = isFocused
            ? colorFillActive
            : isHovered
            ? colorFillHover
            : colorFillDefault;
            const thumbColor = isFocused
            ? colorThumbActive
            : isHovered
            ? colorThumbHover
            : colorThumbDefault;
            const thumbBorderColor = isFocused
            ? colorThumbBorderActive
            : isHovered
            ? colorThumbBorderHover
            : colorThumbBorderDefault;

            const wrapperClasses = `namer-ui-custom-slider-${id}-custom-slider-wrapper${
            disabled ? " disabled" : ""
            }`;
            const trackClass = `namer-ui-custom-slider-${id}-slider-track`;
            const rangeClass = `namer-ui-custom-slider-${id}-slider-range`;
            const thumbClass = `namer-ui-custom-slider-${id}-slider-thumb`;

            return (
            <div>
                <style>{`
                .${wrapperClasses} {
                    position: relative;
                    width: ${width};
                    height: ${thumbHeight};
                    display: flex;
                    align-items: center;
                    cursor: pointer;
                    touch-action: none;
                    outline: none;
                    border-radius: ${trackFillBorderRadius};
                    background: transparent;
                    backdrop-filter: blur(8px) saturate(180%);
                }
                .${wrapperClasses}.disabled {
                    cursor: not-allowed;
                    opacity: 0.5;
                }
                .${trackClass},
                .${rangeClass} {
                    position: absolute;
                    height: ${trackHeight};
                    border-radius: ${trackFillBorderRadius};
                    top: 50%;
                    transform: translateY(-50%);
                    width: 100%;
                    transition: background-color 0.25s ease;
                }
                .${trackClass} {
                    background-color: ${colorTrackBackground};
                }
                .${rangeClass} {
                    background-color: ${fillColor};
                    width: ${percentage}%;
                }
                .${thumbClass} {
                    position: absolute;
                    width: ${thumbWidth};
                    height: ${thumbHeight};
                    border-radius: ${thumbBorderRadius};
                    top: 50%;
                    transform: translateY(-50%);
                    background-color: ${thumbColor};
                    border: ${thumbBorderWidth} solid ${thumbBorderColor};
                    transition: background-color 0.25s ease, border-color 0.25s ease;
                    ${
                    isRTL
                        ? `right: calc(${percentage}% - ${thumbWidth} / 2);`
                        : `left: calc(${percentage}% - ${thumbWidth} / 2);`
                    }
                }
                `}</style>
                <div
                ref={sliderRef}
                className={wrapperClasses}
                onMouseDown={handleMouseDown}
                onMouseEnter={() => setIsHovered(true)}
                onMouseLeave={() => setIsHovered(false)}
                onKeyDown={handleKeyDown}
                onFocus={() => setIsFocused(true)}
                onBlur={() => setIsFocused(false)}
                tabIndex={disabled ? -1 : 0}
                role="slider"
                aria-label={ariaLabel}
                aria-valuemin={min}
                aria-valuemax={max}
                aria-valuenow={value}
                aria-disabled={disabled}
                dir={isRTL ? "rtl" : "ltr"}
                >
                <div className={trackClass} />
                <div className={rangeClass} />
                <div className={thumbClass} />
                </div>
            </div>
            );
        }


        const App = () => {
        const [connected, setConnected] = React.useState(false);
        const [ip, setIp] = React.useState("192.168.xx.xxx");
        const [settings, setSettings] = React.useState({
            stickDeadzone: 10,
            accelDeadzone: 20,
            stickSensitivity: 0.9,
            accelSensitivity: 1.5,
            invertStickY: true,
            invertAccelTilt: true,
            accelEnabled: true,
            invertX: true,
            invertY: false,
        });
        const [telemetry, setTelemetry] = React.useState({ x: 0, y: 0, z: 0, speed: 0 });
        const [velocityVec, setVelocityVec] = React.useState({ x: 0, y: 0, z: 0 });
        const [hue, setHue] = React.useState(window.currentHue ?? 0.6);

        // Dynamic colors derived from hue state
        const dynamicLabelColor = `hsla(${hue * 360}, 80%, 85%, 0.9)`;
        const dynamicAccentColor = `hsla(${hue * 360}, 80%, 70%, 0.9)`;
        const dynamicGlowColor = `hsla(${hue * 360}, 80%, 70%, 0.4)`;
        const sliderFillDefault = `hsla(${hue * 360}, 80%, 75%, 0.75)`;
        const sliderFillHover = `hsla(${hue * 360}, 80%, 90%, 0.9)`;
        const sliderFillActive = `hsla(${hue * 360}, 80%, 95%, 0.95)`;
        const sliderThumbDefault = `hsla(${hue * 360}, 25%, 20%, 0.9)`;
        const sliderThumbHover = `hsla(${hue * 360}, 28%, 30%, 0.95)`;
        const sliderThumbActive = `hsla(${hue * 360}, 95%, 98%, 1.0)`;
        const sliderThumbBorderDefault = `hsla(${hue * 360}, 70%, 85%, 0.85)`;
        const sliderThumbBorderHover = `hsla(${hue * 360}, 80%, 95%, 0.95)`;
        const sliderThumbBorderActive = `hsla(${hue * 360}, 100%, 100%, 1.0)`;

        React.useEffect(() => {
            const id = setInterval(() => {
            if (typeof window.currentHue === "number") {
                setHue(window.currentHue);
            }
            }, 200);
            return () => clearInterval(id);
        }, []);

        React.useEffect(() => {
            window.gameData.settings = {
            ...window.gameData.settings,
            accelEnabled: settings.accelEnabled,
            invertX: settings.invertX,
            invertY: settings.invertY,
            sensitivity: settings.accelSensitivity,
            deadzone: settings.accelDeadzone / 100,
            accelEnableX: true,
            accelEnableY: true,
            stickDeadzone: settings.stickDeadzone,
            stickSensitivity: settings.stickSensitivity,
            invertStickY: settings.invertStickY,
            invertAccelTilt: settings.invertAccelTilt,
            };
        }, [settings]);

        React.useEffect(() => {
            const interval = setInterval(() => {
            setTelemetry({ ...window.gameData.telemetry });
            setVelocityVec(window.gameData.velocity);
            }, 100);
            return () => clearInterval(interval);
        }, []);

        const handleConnect = () => {
            if (!ip) return;
            const ws = new WebSocket(`ws://${ip}:81`);
            ws.onopen = () => {
            setConnected(true);
            console.log("WS Connected");
            };
            ws.onmessage = (e) => {
            try {
                const data = JSON.parse(e.data);
                window.gameData.inputs = data;
            } catch {}
            };
            ws.onclose = () => setConnected(false);
            ws.onerror = () => setConnected(false);
        };

        const toggleSetting = (key) => setSettings((p) => ({ ...p, [key]: !p[key] }));
        const updateSlider = (key, val) => setSettings((p) => ({ ...p, [key]: parseFloat(val) }));

        // Hebrew logic unchanged
        const dot = telemetry.x * velocityVec.x + telemetry.y * velocityVec.y + telemetry.z * velocityVec.z;
        const approachingColor = "#5599ff";
        const recedingColor = "#ff5555";
        let statusLabel = <span className="hebrew-text" style={{ color: "#aaddff" }}>יציב</span>;
        if (Math.abs(telemetry.speed) > 10) {
            if (dot < -100) {
            statusLabel = <span className="hebrew-text" style={{ color: approachingColor }}>מתקרב</span>;
            } else if (dot > 100) {
            statusLabel = <span className="hebrew-text" style={{ color: recedingColor }}>מתרחק</span>;
            }
        }

        const panelStyle = getLegacyBackdropStyle({
            supportsBackdropFilter,
            bodyOpacity: 0.6,
            borderOpacity: 0.25,
            blurStrength: 11,
            isScrolled: true,
        });

        const separatorStyle = {
            borderBottom: `1px solid hsla(${hue * 360}, 80%, 65%, 0.7)`,
            paddingBottom: 4,
            marginBottom: 8,
        };

        const buttonStyle = {
            ...getLegacyBackdropStyle({
            supportsBackdropFilter,
            bodyOpacity: 0.4,
            borderOpacity: 0.3,
            blurStrength: 11,
            isScrolled: true,
            }),
            padding: "6px 16px",
            borderRadius: "999px",
            background: `linear-gradient(135deg, hsla(${hue * 360},80%,55%,0.36), hsla(${hue * 360},80%,40%,0.32))`,
            borderColor: `hsla(${hue * 360},80%,70%,0.6)`,
            color: dynamicLabelColor,
        };

        const glassCheckboxRow = {
            ...getLegacyBackdropStyle({
            supportsBackdropFilter,
            bodyOpacity: 0.45,
            borderOpacity: 0.18,
            blurStrength: 11,
            isScrolled: true,
            }),
            padding: "6px 10px",
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            gap: "10px",
        };

        const headerTitleStyle = {
            margin: 0,
            fontSize: 16,
            textTransform: "uppercase",
            letterSpacing: "1.5px",
            color: dynamicLabelColor,
        };

        const statusDotStyle = {
            width: 9,
            height: 9,
        };

        return (
            <div className="hud-wrapper">
            {/* Top Left: The Space Stuff */}
            <div className="panel" style={panelStyle}>
                <div className="header-row" style={separatorStyle}>
                <h2 style={headerTitleStyle}>The Space Stuff</h2>
                <div style={{ fontSize: 11, color: dynamicLabelColor }}>
                    <span className={`status-dot ${connected ? "connected" : "error"}`} style={statusDotStyle}></span>{" "}
                    {connected ? "ONLINE" : "OFFLINE"}
                </div>
                </div>

                {!connected && (
                <div style={{ marginBottom: 18, display: "flex", gap: 8, alignItems: "center" }}>
                <input
                type="text"
                value={ip}
                onChange={(e) => setIp(e.target.value)}
                style={{
                    color: dynamicLabelColor,
                    borderColor: dynamicLabelColor,
                    paddingLeft: "12px",    // horizontal padding same for left and right
                    paddingRight: "12px",
                    borderRadius: "999px",  // fully rounded like buttons
                    outline: "none",        // for consistent focus styling
                }}
                />
                <button style={buttonStyle} onClick={handleConnect}>Link</button>
                </div>
                )}

                <div className="control-panel">
                <div className="control-group">
                    <label style={{ color: dynamicLabelColor }}>
                    Stick Sensitivity: {settings.stickSensitivity.toFixed(1)}
                    </label>
                    <CustomSlider
                    id="stick-sens"
                    min={0.1}
                    max={5.0}
                    step={0.1}
                    value={settings.stickSensitivity}
                    onValueChange={(v) => updateSlider("stickSensitivity", v)}
                    ariaLabel="Stick Sensitivity"
                    colorFillDefault={sliderFillDefault}
                    colorFillHover={sliderFillHover}
                    colorFillActive={sliderFillActive}
                    colorThumbDefault={sliderThumbDefault}
                    colorThumbHover={sliderThumbHover}
                    colorThumbActive={sliderThumbActive}
                    colorThumbBorderDefault={sliderThumbBorderDefault}
                    colorThumbBorderHover={sliderThumbBorderHover}
                    colorThumbBorderActive={sliderThumbBorderActive}
                    />
                </div>

                <div className="control-group">
                    <label style={{ color: dynamicLabelColor }}>
                    Accel Sensitivity: {settings.accelSensitivity.toFixed(1)}
                    </label>
                    <CustomSlider
                    id="accel-sens"
                    min={0.1}
                    max={5.0}
                    step={0.1}
                    value={settings.accelSensitivity}
                    onValueChange={(v) => updateSlider("accelSensitivity", v)}
                    ariaLabel="Accelerometer Sensitivity"
                    colorFillDefault={sliderFillDefault}
                    colorFillHover={sliderFillHover}
                    colorFillActive={sliderFillActive}
                    colorThumbDefault={sliderThumbDefault}
                    colorThumbHover={sliderThumbHover}
                    colorThumbActive={sliderThumbActive}
                    colorThumbBorderDefault={sliderThumbBorderDefault}
                    colorThumbBorderHover={sliderThumbBorderHover}
                    colorThumbBorderActive={sliderThumbBorderActive}
                    />
                </div>

                <div className="control-group">
                    <label style={{ color: dynamicLabelColor }}>
                    Stick Deadzone: {settings.stickDeadzone.toFixed(0)}
                    </label>
                    <CustomSlider
                    id="stick-deadzone"
                    min={5}
                    max={85}
                    step={1}
                    value={settings.stickDeadzone}
                    onValueChange={(v) => updateSlider("stickDeadzone", v)}
                    ariaLabel="Stick Deadzone"
                    colorFillDefault={sliderFillDefault}
                    colorFillHover={sliderFillHover}
                    colorFillActive={sliderFillActive}
                    colorThumbDefault={sliderThumbDefault}
                    colorThumbHover={sliderThumbHover}
                    colorThumbActive={sliderThumbActive}
                    colorThumbBorderDefault={sliderThumbBorderDefault}
                    colorThumbBorderHover={sliderThumbBorderHover}
                    colorThumbBorderActive={sliderThumbBorderActive}
                    />
                </div>

                <div className="control-group">
                    <label style={{ color: dynamicLabelColor }}>
                    Accel Deadzone: {settings.accelDeadzone.toFixed(0)}
                    </label>
                    <CustomSlider
                    id="accel-deadzone"
                    min={5}
                    max={85}
                    step={1}
                    value={settings.accelDeadzone}
                    onValueChange={(v) => updateSlider("accelDeadzone", v)}
                    ariaLabel="Accelerometer Deadzone"
                    colorFillDefault={sliderFillDefault}
                    colorFillHover={sliderFillHover}
                    colorFillActive={sliderFillActive}
                    colorThumbDefault={sliderThumbDefault}
                    colorThumbHover={sliderThumbHover}
                    colorThumbActive={sliderThumbActive}
                    colorThumbBorderDefault={sliderThumbBorderDefault}
                    colorThumbBorderHover={sliderThumbBorderHover}
                    colorThumbBorderActive={sliderThumbBorderActive}
                    />
                </div>

                <div style={glassCheckboxRow}>
                    <CustomCheckbox
                    checked={settings.invertStickY}
                    onChange={() => toggleSetting("invertStickY")}
                    label="Reverse Stick Y"
                    size={20}
                    borderRadius="6px"
                    accentColor={dynamicAccentColor}
                    glowColor={dynamicGlowColor}
                    labelColor={dynamicLabelColor}
                    />

                    <CustomCheckbox
                    checked={settings.invertAccelTilt}
                    onChange={() => toggleSetting("invertAccelTilt")}
                    label="Reverse Tilt"
                    size={20}
                    borderRadius="6px"
                    accentColor={dynamicAccentColor}
                    glowColor={dynamicGlowColor}
                    labelColor={dynamicLabelColor}
                    />
                </div>

                <div style={{ display: "flex", justifyContent: "space-between", marginTop: 12, gap: 8 }}>

                <button
                    style={buttonStyle}
                    onClick={() => window.triggerMorph && window.triggerMorph()}
                >
                    Next Shape
                </button>
                <button
                    style={buttonStyle}
                    onClick={() => window.triggerHueShift && window.triggerHueShift()}
                >
                    Shift Hue
                </button>
                <button
                    style={buttonStyle}
                    onClick={() => window.triggerPhase && window.triggerPhase()}
                >
                    Phase
                </button>
                </div>
                </div>

            {/* Bottom Left: Telemetry */}
            <div className="panel" style={panelStyle}>
                <div className="header-row" style={separatorStyle}>
                <h2 style={headerTitleStyle}>Telemetry</h2>
                </div>
                <div className="data-display" style={{ color: dynamicLabelColor }}>
                    POS X: <span className="val">{telemetry.x.toFixed(0)}</span><br/>
                    POS Y: <span className="val">{telemetry.y.toFixed(0)}</span><br/>
                    POS Z: <span className="val">{telemetry.z.toFixed(0)}</span><br/>
                    VELOCITY: <span className="val">{telemetry.speed.toFixed(0)} MPH</span><br/>
                    STATUS: {statusLabel}
                </div>
            </div>
            </div>
            </div>
        );
        };

        const root = ReactDOM.createRoot(document.getElementById("root"));
        root.render(<App />);
    </script>

    <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import anime from 'animejs';
    import { createNoise3D, createNoise4D } from 'simplex-noise';

    // --- Globals ---
    let scene, camera, renderer, composer, clock;
    let particlesGeometry, particlesMaterial, particleSystem;
    let currentPositions, sourcePositions, targetPositions, swarmPositions;
    let particleSizes, particleOpacities, particleEffectStrengths, aShineArray;
    let noise3D, noise4D;
    let isMorphing = false;
    let morphTimeline = null;
    let currentShapeIndex = 3;
    let morphState = { progress: 0.0 };

    // Physics / Movement
    const velocity = new THREE.Vector3();
    let smoothPitch = 0;
    let smoothRoll = 0;

    // Buttons / input state
    let cClickTimeout = null;
    let cClickCount = 0;
    let cClickTimer = null;
    let cPressed = false;
    let zClickCount = 0;
    let zClickTimer = null;
    let zPressed = false;
    let zClickTimeout = null;
    let zDoubleClickDetected = false;

    // Phase / wave state
    let phaseState = {
    active: false,
    startTime: 0,
    speed: 350,
    duration: 4.0,
    radiusMax: 4000,
    origin: new THREE.Vector3()
    };
    let isPhasing = false;

    window.currentHue = window.currentHue ?? 0.6;
    let currentHue = window.currentHue;

    const CONFIG = {
    particleCount: 25000,
    shapeSize: 250,
    swirlFactor: 5.0,
    noiseFrequency: 0.02,
    morphDuration: 3000,
    bloomStrength: 1.8,
    bloomRadius: 0.8,
    bloomThreshold: 0.1,
    maxSpeed: 800,
    drag: 0.96,
    zDoubleClickWindow: 500
    };

    // Keyboard + mouse nav state
    window.keysForNav = {};
    window.mouseDownForNav = false;
    window.addEventListener('keydown', (e) => { window.keysForNav[e.key.toLowerCase()] = true; });
    window.addEventListener('keyup', (e) => { window.keysForNav[e.key.toLowerCase()] = false; });
    window.addEventListener('mousedown', (e) => { if (e.button === 0) window.mouseDownForNav = true; });
    window.addEventListener('mouseup', (e) => { if (e.button === 0) window.mouseDownForNav = false; });

    // --- Shape Generators ---
    function generateSphere(count, size) {
    const points = new Float32Array(count * 3);
    const phi = Math.PI * (Math.sqrt(5) - 1);
    for (let i = 0; i < count; i++) {
        const y = 1 - (i / (count - 1)) * 2;
        const radius = Math.sqrt(1 - y * y);
        const theta = phi * i;
        points[i * 3] = Math.cos(theta) * radius * size;
        points[i * 3 + 1] = y * size;
        points[i * 3 + 2] = Math.sin(theta) * radius * size;
    }
    return points;
    }

    function generateGalaxy(count, size) {
    const points = new Float32Array(count * 3);
    const arms = 5;
    for (let i = 0; i < count; i++) {
        const t = Math.pow(Math.random(), 1.5);
        const radius = t * size * 1.5;
        const armOffset = (Math.floor(Math.random() * arms) / arms) * Math.PI * 2;
        const rotation = (radius / size) * 5;
        const theta = armOffset + rotation + (Math.random() - 0.5) * 0.5;
        points[i * 3] = radius * Math.cos(theta);
        points[i * 3 + 1] = (Math.random() - 0.5) * size * 0.2 * (1 - t);
        points[i * 3 + 2] = radius * Math.sin(theta);
    }
    return points;
    }

    function generateLotusOrb(count, size) {
    const points = new Float32Array(count * 3);
    const phi = Math.PI * (Math.sqrt(5) - 1);
    const radDisplace = size * 0.2;
    for (let i = 0; i < count; i++) {
        const y = 1 - (i / (count - 1)) * 2;
        const rBase = Math.sqrt(1 - y * y);
        const theta = phi * i;
        const x0 = Math.cos(theta) * rBase;
        const z0 = Math.sin(theta) * rBase;
        const lon = Math.atan2(z0, x0);
        const lat = Math.asin(y);
        const disp = Math.sin(6 * lon + Math.cos(4 * lat) * 2.0) * radDisplace;
        const r = size + disp;
        points[i * 3] = x0 * r;
        points[i * 3 + 1] = y * size;
        points[i * 3 + 2] = z0 * r;
    }
    return points;
    }

    function generateDoubleHelix(count, size) {
    const points = new Float32Array(count * 3);
    const turns = 5;
    const height = size * 2.5;
    for (let i = 0; i < count; i++) {
        const t = i / count;
        const angle = t * Math.PI * 2 * turns;
        const y = (t - 0.5) * height;
        const radius = size * 0.5;
        const strand = i % 2 === 0 ? 1 : -1;
        const phase = strand === 1 ? 0 : Math.PI;
        points[i * 3] = Math.cos(angle + phase) * radius + (Math.random() - 0.5) * 20;
        points[i * 3 + 1] = y;
        points[i * 3 + 2] = Math.sin(angle + phase) * radius + (Math.random() - 0.5) * 20;
    }
    return points;
    }

    function generateTorus(count, size) {
    const points = new Float32Array(count * 3);
    const R = size * 0.8;
    const r = size * 0.3;
    for (let i = 0; i < count; i++) {
        const u = Math.random() * Math.PI * 2;
        const v = Math.random() * Math.PI * 2;
        points[i * 3] = (R + r * Math.cos(v)) * Math.cos(u);
        points[i * 3 + 1] = r * Math.sin(v);
        points[i * 3 + 2] = (R + r * Math.cos(v)) * Math.sin(u);
    }
    return points;
    }

    const SHAPES = [
    { name: 'Sphere', generator: generateSphere },
    { name: 'Galaxy', generator: generateGalaxy },
    { name: 'DoubleHelix', generator: generateDoubleHelix },
    { name: 'Lotus', generator: generateLotusOrb },
    { name: 'Torus', generator: generateTorus },
    ];

    // --- Init Function ---
    function init() {
    clock = new THREE.Clock();
    noise3D = createNoise3D();
    noise4D = createNoise4D();
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000810, 0.0005);
    camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
    camera.position.set(0, 100, 800);
    renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    document.body.appendChild(renderer.domElement);

    const renderScene = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), CONFIG.bloomStrength, CONFIG.bloomRadius, CONFIG.bloomThreshold);
    composer = new EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    createStarfield();
    createParticleSystem();
    window.addEventListener('resize', onWindowResize);

    setTimeout(() => {
        const el = document.getElementById('loading');
        if (el) el.classList.add('fade-out');
    }, 1000);

    animate();
    }

    function createStarTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 32;
    canvas.height = 32;
    const ctx = canvas.getContext('2d');
    const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
    grad.addColorStop(0, 'rgba(255,255,255,1)');
    grad.addColorStop(0.2, 'rgba(255,255,255,0.8)');
    grad.addColorStop(0.5, 'rgba(255,255,255,0.2)');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 32, 32);
    return new THREE.CanvasTexture(canvas);
    }

    function createStarfield() {
    const geo = new THREE.BufferGeometry();
    const pos = [];
    const cols = [];
    for (let i = 0; i < 15000; i++) {
        pos.push((Math.random() - 0.5) * 8000, (Math.random() - 0.5) * 8000, (Math.random() - 0.5) * 8000);
        const c = new THREE.Color().setHSL(0.6 + Math.random() * 0.1, 0.8, 0.8);
        cols.push(c.r, c.g, c.b);
    }
    geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
    geo.setAttribute('color', new THREE.Float32BufferAttribute(cols, 3));
    const mat = new THREE.PointsMaterial({
        size: 3,
        vertexColors: true,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending,
    });
    scene.add(new THREE.Points(geo, mat));
    }

    function createParticleSystem() {
    targetPositions = SHAPES.map((s) => s.generator(CONFIG.particleCount, CONFIG.shapeSize));
    currentShapeIndex = 3;
    currentPositions = new Float32Array(targetPositions[currentShapeIndex]);
    sourcePositions = new Float32Array(targetPositions[currentShapeIndex]);
    swarmPositions = new Float32Array(CONFIG.particleCount * 3);

    particlesGeometry = new THREE.BufferGeometry();
    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));

    particleSizes = new Float32Array(CONFIG.particleCount);
    particleOpacities = new Float32Array(CONFIG.particleCount);
    particleEffectStrengths = new Float32Array(CONFIG.particleCount);
    aShineArray = new Float32Array(CONFIG.particleCount);

    const colors = new Float32Array(CONFIG.particleCount * 3);
    for (let i = 0; i < CONFIG.particleCount; i++) {
        particleSizes[i] = Math.random() * 2 + 0.5;
        particleOpacities[i] = 0.6 + Math.random() * 0.4;
        particleEffectStrengths[i] = 0.0;
        aShineArray[i] = 0.0;
    }

    particlesGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
    particlesGeometry.setAttribute('opacity', new THREE.BufferAttribute(particleOpacities, 1));
    particlesGeometry.setAttribute('aEffectStrength', new THREE.BufferAttribute(particleEffectStrengths, 1));
    particlesGeometry.setAttribute('aShine', new THREE.BufferAttribute(aShineArray, 1));
    particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    updateColors(currentHue);

    particlesMaterial = new THREE.ShaderMaterial({
        uniforms: {
        pointTexture: { value: createStarTexture() },
        },
        vertexShader: `
        attribute float size;
        attribute float opacity;
        attribute float aEffectStrength;
        attribute float aShine;
        varying vec3 vColor;
        varying float vOpacity;
        varying float vShine;
        void main() {
            vColor = color;
            vOpacity = opacity;
            vShine = aShine;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            float finalSize = size * (1.0 + aEffectStrength * 2.0 + aShine * 5.0);
            gl_PointSize = finalSize * (400.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
        }
        `,
        fragmentShader: `
        uniform sampler2D pointTexture;
        varying vec3 vColor;
        varying float vOpacity;
        varying float vShine;
        void main() {
            vec4 tex = texture2D(pointTexture, gl_PointCoord);
            if (tex.a < 0.05) discard;
            vec3 finalColor = vColor + (vec3(1.0) * vShine * 2.0);
            gl_FragColor = vec4(finalColor, tex.a * vOpacity);
        }
        `,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        vertexColors: true,
    });

    particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
    scene.add(particleSystem);
    }

    function updateColors(hueBase) {
    const colors = particlesGeometry.attributes.color.array;
    const pos = particlesGeometry.attributes.position.array;
    for (let i = 0; i < CONFIG.particleCount; i++) {
        const x = pos[i * 3], y = pos[i * 3 + 1], z = pos[i * 3 + 2];
        const dist = Math.sqrt(x * x + y * y + z * z);
        const noiseVal = noise3D(x * 0.002, y * 0.002, z * 0.002);
        let h = hueBase + dist * 0.0005 + noiseVal * 0.1;
        if (h > 1) h -= 1;
        const c = new THREE.Color().setHSL(h, 0.8, 0.6 + noiseVal * 0.2);
        colors[i * 3] = c.r;
        colors[i * 3 + 1] = c.g;
        colors[i * 3 + 2] = c.b;
    }
    particlesGeometry.attributes.color.needsUpdate = true;
    }

    function triggerHueShift() {
    currentHue = Math.random();
    window.currentHue = currentHue;
    updateColors(currentHue);
    anime({
        targets: particlesGeometry.attributes.aShine.array,
        0: 0,
        update: () => {
        for (let i = 0; i < CONFIG.particleCount; i++) {
            if (Math.random() < 0.05) {
            particlesGeometry.attributes.aShine.array[i] = Math.max(0, particlesGeometry.attributes.aShine.array[i] - 0.05);
            }
            if (Math.random() < 0.01) particlesGeometry.attributes.aShine.array[i] = 1.0;
        }
        particlesGeometry.attributes.aShine.needsUpdate = true;
        },
        easing: 'easeOutExpo',
        duration: 1000,
    });
    }

    function triggerMorph() {
    if (isMorphing) return;
    isMorphing = true;
    const nextIndex = (currentShapeIndex + 1) % SHAPES.length;
    sourcePositions.set(currentPositions);
    const targets = targetPositions[nextIndex];
    const tempVec = new THREE.Vector3();
    const sVec = new THREE.Vector3();
    const tVec = new THREE.Vector3();
    for (let i = 0; i < CONFIG.particleCount; i++) {
        sVec.fromArray(sourcePositions, i * 3);
        tVec.fromArray(targets, i * 3);
        tempVec.lerpVectors(sVec, tVec, 0.5);
        const noiseDir = new THREE.Vector3(noise3D(i, 0, 0), noise3D(0, i, 0), noise3D(0, 0, i)).normalize();
        tempVec.addScaledVector(noiseDir, CONFIG.shapeSize * 1.5);
        swarmPositions[i * 3] = tempVec.x;
        swarmPositions[i * 3 + 1] = tempVec.y;
        swarmPositions[i * 3 + 2] = tempVec.z;
    }
    currentShapeIndex = nextIndex;
    morphState.progress = 0;
    if (morphTimeline) morphTimeline.pause();
    morphTimeline = anime({
        targets: morphState,
        progress: 1,
        duration: CONFIG.morphDuration,
        easing: 'easeInOutCubic',
        complete: () => {
        isMorphing = false;
        updateColors(currentHue);
        },
    });
    }

    function triggerPhase() {
    phaseState.origin.copy(camera.position);
    phaseState.startTime = clock.getElapsedTime();
    phaseState.active = true;
    if (!isPhasing) {
        isPhasing = true;
        anime({
        targets: aShineArray,
        update: () => {
            for (let i = 0; i < CONFIG.particleCount; i++) {
            aShineArray[i] = Math.min(1, aShineArray[i] + 0.15);
            }
            particlesGeometry.attributes.aShine.needsUpdate = true;
        },
        duration: 150,
        easing: 'linear',
        complete: () => { isPhasing = false; },
        });
    }
    }

const DOUBLE_CLICK_DELAY = 500; // ms

// *** FIXED C BUTTON: Single = Morph, Double = Toggle Accel ***
function handleCButtonClick() {
    cClickCount++;
    
    if (cClickTimer) clearTimeout(cClickTimer);
    
    if (cClickCount === 2) {
        // Double click detected IMMEDIATELY - execute and reset
        clearTimeout(cClickTimer);
        window.gameData.settings.accelEnabled = !window.gameData.settings.accelEnabled;
        cClickCount = 0;
        cClickTimer = null;
        console.log("C Double Click: Accel Toggled");
        return;
    }
    
    // First click - wait for possible second click
    cClickTimer = setTimeout(() => {
        if (cClickCount === 1) {
            // Single click confirmed
            triggerMorph();
            console.log("C Single Click: Morph");
        }
        cClickCount = 0;
        cClickTimer = null;
    }, DOUBLE_CLICK_DELAY);
}

// *** FIXED Z BUTTON: Single = Phase, Double = Hue Shift ***
function handleZButtonClick() {
    zClickCount++;
    
    if (zClickTimer) clearTimeout(zClickTimer);
    
    if (zClickCount === 2) {
        // Double click detected IMMEDIATELY - execute and reset
        clearTimeout(zClickTimer);
        triggerHueShift();
        console.log("Z Double Click: Hue Shift");
        zClickCount = 0;
        zClickTimer = null;
        return;
    }
    
    // First click - wait for possible second click
    zClickTimer = setTimeout(() => {
        if (zClickCount === 1) {
            // Single click confirmed
            triggerPhase();
            console.log("Z Single Click: Phase");
        }
        zClickCount = 0;
        zClickTimer = null;
    }, DOUBLE_CLICK_DELAY);
}

    function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    const time = clock.getElapsedTime();
    const inputs = window.gameData.inputs;
    const settings = window.gameData.settings;

    // C BUTTON HANDLING (NEW BEHAVIOR)
    if (inputs.c === 1 && !cPressed) {
        handleCButtonClick();
        cPressed = true;
    } else if (inputs.c === 0) {
        cPressed = false;
    }

    let speedMult = 1.0;
    if (inputs.z === 1 && !zPressed) {
        handleZButtonClick();
        zPressed = true;
        speedMult = 3.0; // Z hold still speeds up movement
    } else if (inputs.z === 0) {
        zPressed = false;
    }


    // *** EXACT ORIGINAL ACCELEROMETER & STICK INPUTS ***
    let targetPitch = 0;
    let targetRoll = 0;
    if (settings.accelEnabled) {
        const mapRange = (val, min, max, a, b) => ((val - min) * (b - a)) / (max - min) + a;
        let rawX = mapRange(inputs.ax, 300, 720, -1, 1);
        let rawY = mapRange(inputs.ay, 300, 720, -1, 1);
        const accelDZ = settings.deadzone || 0.2;
        rawX = Math.abs(rawX) < accelDZ ? 0 : rawX;
        rawY = Math.abs(rawY) < accelDZ ? 0 : rawY;
        let ctrlX = settings.accelEnableX ? rawX : 0;
        let ctrlY = settings.accelEnableY ? rawY : 0;
        if (settings.invertX) ctrlX *= -1;
        if (settings.invertY) ctrlY *= -1;
        if (settings.invertAccelTilt) ctrlY *= -1;
        const accelSens = settings.accelSensitivity || settings.sensitivity || 1.5;
        targetRoll = -ctrlX * accelSens;
        targetPitch = ctrlY * accelSens;
    }

    smoothPitch += (targetPitch - smoothPitch) * 0.1;
    smoothRoll += (targetRoll - smoothRoll) * 0.1;
    camera.rotateX(smoothPitch * dt);
    camera.rotateZ(smoothRoll * dt * 0.5);

    // *** EXACT ORIGINAL STICK INPUTS ***
    let throttle = 0;
    let strafe = 0;
    const stickDZ = settings.stickDeadzone || 10;
    if (Math.abs(inputs.jy - 128) > stickDZ) {
        let v = -(inputs.jy - 128) / 128;
        if (settings.invertStickY) v *= -1;
        throttle += v;
    }
    if (Math.abs(inputs.jx - 128) > stickDZ) {
        strafe += (inputs.jx - 128) / 128;
    }
    if (window.mouseDownForNav) {
        const keys = window.keysForNav;
        if (keys['w'] || keys['arrowup']) throttle += 1;
        if (keys['s'] || keys['arrowdown']) throttle -= 1;
        if (keys['a'] || keys['arrowleft']) strafe -= 1;
        if (keys['d'] || keys['arrowright']) strafe += 1;
    }
    throttle = Math.max(-1, Math.min(1, throttle));
    strafe = Math.max(-1, Math.min(1, strafe));
    const stickSens = settings.stickSensitivity || 1.5;
    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
    const moveForce = new THREE.Vector3()
        .addScaledVector(forward, throttle * stickSens * CONFIG.maxSpeed * speedMult * dt)
        .addScaledVector(right, strafe * stickSens * CONFIG.maxSpeed * dt);
    velocity.add(moveForce);
    velocity.multiplyScalar(CONFIG.drag);
    camera.position.add(velocity);

    window.gameData.telemetry.x = camera.position.x;
    window.gameData.telemetry.y = camera.position.y;
    window.gameData.telemetry.z = camera.position.z;
    window.gameData.telemetry.speed = velocity.length() * 10;
    window.gameData.velocity = { x: velocity.x, y: velocity.y, z: velocity.z };

    const posAttr = particlesGeometry.attributes.position;
    const effAttr = particlesGeometry.attributes.aEffectStrength;
    const t = morphState.progress;
    const targetShape = targetPositions[currentShapeIndex];
    const t_inv = 1 - t;
    const t_sq = t * t;
    const t_inv_sq = t_inv * t_inv;
    const p0 = new THREE.Vector3();
    const p1 = new THREE.Vector3();
    const p2 = new THREE.Vector3();
    const res = new THREE.Vector3();
    const timeNow = clock.getElapsedTime();
    const noiseTime = timeNow * 0.2;

    let phaseActive = false;
    let phaseRadius = 0;
    const phaseThickness = CONFIG.shapeSize * 0.25;
    const phaseAmplitude = CONFIG.shapeSize * 0.25;
    if (phaseState.active) {
        const elapsed = timeNow - phaseState.startTime;
        if (elapsed >= 0 && elapsed <= phaseState.duration) {
        phaseActive = true;
        phaseRadius = Math.min(elapsed * phaseState.speed, phaseState.radiusMax);
        } else {
        phaseState.active = false;
        }
    }

    for (let i = 0; i < CONFIG.particleCount; i++) {
        const i3 = i * 3;
        if (isMorphing) {
        p0.fromArray(sourcePositions, i3);
        p1.fromArray(swarmPositions, i3);
        p2.fromArray(targetShape, i3);
        res.copy(p0).multiplyScalar(t_inv_sq).addScaledVector(p1, 2 * t_inv * t).addScaledVector(p2, t_sq);
        const swirlStr = Math.sin(t * Math.PI) * CONFIG.swirlFactor;
        if (swirlStr > 0.1) {
            const swirlDir = new THREE.Vector3(
            noise3D(p1.x * 0.01, timeNow, 0),
            noise3D(0, p1.y * 0.01, timeNow),
            noise3D(timeNow, 0, p1.z * 0.01)
            ).normalize();
            const offset = new THREE.Vector3().crossVectors(res, swirlDir).multiplyScalar(swirlStr * 2);
            res.add(offset);
        }
        effAttr.array[i] = Math.sin(t * Math.PI);
        } else {
        res.fromArray(targetShape, i3);
        const nX = noise4D(res.x * 0.005, res.y * 0.005, res.z * 0.005, noiseTime);
        const nY = noise4D(res.x * 0.005 + 100, res.y * 0.005, res.z * 0.005, noiseTime);
        const nZ = noise4D(res.x * 0.005 + 200, res.y * 0.005, res.z * 0.005, noiseTime);
        res.x += nX * 10;
        res.y += nY * 10;
        res.z += nZ * 10;
        if (aShineArray[i] > 0) aShineArray[i] *= 0.95;
        effAttr.array[i] = 0;
        }

        if (phaseActive) {
        const v = new THREE.Vector3(res.x, res.y, res.z).sub(phaseState.origin);
        const dist = v.length();
        if (dist > 0.0001) {
            const d = Math.abs(dist - phaseRadius);
            const shell = 1.0 - THREE.MathUtils.clamp(d / phaseThickness, 0.0, 1.0);
            if (shell > 0.0) {
            v.divideScalar(dist);
            const push = phaseAmplitude * shell;
            res.addScaledVector(v, push);
            effAttr.array[i] += shell * 0.7;
            aShineArray[i] = Math.min(1.0, aShineArray[i] + shell);
            }
        }
        }

        posAttr.array[i3] = res.x;
        posAttr.array[i3 + 1] = res.y;
        posAttr.array[i3 + 2] = res.z;
    }

    posAttr.needsUpdate = true;
    effAttr.needsUpdate = true;
    particlesGeometry.attributes.aShine.needsUpdate = true;

    composer.render();
    }

    function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
    }

    window.triggerHueShift = triggerHueShift;
    window.triggerMorph = triggerMorph;
    window.triggerPhase = triggerPhase;
    init();
    </script>


</body>
</html>
